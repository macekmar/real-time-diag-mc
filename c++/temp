TEMP

 if (world.rank() == 0){
   std::cout << "U: " << params.U << std::endl;
   std::cout << "U_aux: " << params.U_aux << std::endl;
 }




parameters.hpp
 bool print_aux_stats = false;


moves.cpp

#include <math.h>

 // ------------ QMC Auxillary MC move --------------------------------------

dcomplex auxmc::attempt() {

if (params.print_aux_stats) {
 std::cout << std::endl << "AuxMC move" << std::endl;
}

 mpi::communicator world;
 mpi::communicator self = MPI_COMM_SELF;
 world.barrier();

 before_attempt();

 int i;
 // Set aux_config state to main config state
 // If the previous move was accepted, we do not have to reset aux_config
 auto k_current = config.order;
 if (!move_accepted) {
  vertices = config.vertices_list();
  aux_config->reset_to_vertices(vertices);
  aux_config->evaluate();
  aux_config->accept_config();
 }
 auto aux_accepted_weight = aux_config->accepted_weight;
 // Also save the current config
 old_vertices = vertices;

 // Do auxiliary MC run
 // TODO: in `solver_core.cpp` in `clock_callback` the argument is the variable
 //       `max_time instead` of -1 (which is the default value of `max_time`)
 aux_mc->run(params.nb_aux_mc_cycles, 1, triqs::utility::clock_callback(-1), false);
 // Print some statistics
if (params.print_aux_stats) {
 aux_mc->collect_results(self);
 auto aux_mc_duration = aux_mc->get_duration();
 auto cum_aux_mc_duration = mpi::mpi_all_reduce(aux_mc_duration);


 // Moves statistics
 if (world.rank() == 0) {
  std::cout << "Duration (all nodes): " << cum_aux_mc_duration << " seconds" << std::endl;
  for (auto const& x : aux_mc->get_acceptance_rates()) {
   std::cout << "> " << x.first << ": " << x.second << std::endl;
  }
 }
 // pn histogram of the accepted moves of the AuxMC
 auto sum_pn = 0;
 std::cout << "AuxMC pn = [";
 for (auto p = aux_config->pn.begin(); p != aux_config->pn.end(); ++p)
 {
  sum_pn += *p;
  std::cout << *p << " ";
  *p = 0;
 }
 std::cout << "] (the sum is = " << sum_pn << ")" << std::endl;

 std::cout << "Proposed orders = [";
 ++proposed_order[aux_config->order];
 for (auto r = proposed_order.begin(); r != proposed_order.end(); ++r)
 {
  std::cout << *r << " ";
 }
 std::cout << "]" << std::endl;
}
 
 auto aux_current_weight = aux_config->accepted_weight;
 // Set the main config state to final aux_config state
 auto k_attempted = aux_config->order;
 vertices = aux_config->vertices_list();
 config.reset_to_vertices(vertices);
 config.evaluate();
 after_attempt();

 double U_prod = 1.0;
 double U_prod_aux = 1.0;
 double temp;
 /**
  * Marjan: 
  * aux_..._weights do not include U_aux although it is used in the aux Markov
  * chain.
  * U_qmc is just an additional parameter to overcome different magnitudes of
  * qmc weights.
 */
  int sgn = k_attempted > k_current ? 1 : -1;
 for (i = 0; i < abs(k_attempted - k_current); i++) {
  U_prod *= U[k_current + sgn*i];

  if (k_current + sgn*i == 0) {temp = 1.0;}
  else {temp = params.U_aux[k_current + sgn*i - 1];}
  U_prod_aux *= temp;
 };
 if (sgn < 0) U_prod = 1.0/U_prod;
 if (sgn < 0) U_prod_aux = 1.0/U_prod_aux;

if (params.print_aux_stats) {
 std::cout 
  << k_current << " " << k_attempted
  << " " << U_prod << " " << U_prod_aux
  << " AA=" << std::abs(aux_accepted_weight) << " AC=" << std::abs(aux_current_weight) 
  << " CA=" << std::abs(config.accepted_weight) << " CC=" << std::abs(config.current_weight) 
  << std::endl;
 std::cout << U_prod/U_prod_aux
  << " " << std::abs(aux_current_weight) / std::abs(aux_accepted_weight)
  << " " << std::abs(config.current_weight) /std::abs(config.accepted_weight) 
  << std::endl;
 std::cout << std::abs(U_prod/U_prod_aux * aux_accepted_weight/aux_current_weight * config.current_weight / config.accepted_weight)
  << std::endl;
}

 // The Metropolis ratio;
 return U_prod/U_prod_aux * aux_accepted_weight/aux_current_weight * config.current_weight / config.accepted_weight;
}